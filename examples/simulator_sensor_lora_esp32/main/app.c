// -----------------------------------------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------------------------------------

/*
 * EBYTE E22-xxxTxxD multi-sensor simulator transmitter (ESP-IDF)
 *
 * Simulates 16 sensors across 9 variant types and transmits iotdata-encoded
 * packets via the E22 LoRa radio module at randomised intervals (5-15s).
 *
 * No real sensors — all readings are generated by iotdata_variant_simulator.
 * The LoRa module handles duty cycling.
 */

// -----------------------------------------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------------------------------------

#include <stdbool.h>
#include <stdint.h>
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
#pragma GCC diagnostic ignored "-Wnested-externs"
#pragma GCC diagnostic ignored "-Wredundant-decls"
#include "esp_log.h"
#include "esp_timer.h"
#include "esp_random.h"
#include "esp_rom_sys.h"
#include "driver/gpio.h"
#include "driver/uart.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#pragma GCC diagnostic pop

// -----------------------------------------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------------------------------------

#define STARTUP_DELAY_MS  (3 * 1000)
#define RSSI_INTERVAL_MS  (5 * 1000)
#define POLL_INTERVAL_MS  100 /* simulator poll granularity */
#define STATUS_EVERY_N_TX 50  /* print status every N transmissions */

// -----------------------------------------------------------------------------------------------------------------------------------------
// EBYTE E22-xxxTxx DIP module GPIO and UART configuration
// -----------------------------------------------------------------------------------------------------------------------------------------

#define PIN_E22_M0        GPIO_NUM_5 /* E22 pin (1) */
#define PIN_E22_M1        GPIO_NUM_6 /* E22 pin (2) */
#define PIN_E22_RXD       GPIO_NUM_7 /* E22 pin (3) ESP TX -> module RXD */
#define PIN_E22_TXD       GPIO_NUM_8 /* E22 pin (4) module TXD -> ESP RX */
#define PIN_E22_AUX       GPIO_NUM_9 /* E22 pin (5) */
#define PIN_E22_VCC                  /* E22 pin (6) */
#define PIN_E22_GND                  /* E22 pin (7) */

#define E22_UART          UART_NUM_1
#define E22_UART_BUF_SIZE 512

// -----------------------------------------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------------------------------------

static const char *TAG = "app";

static inline uint32_t millis(void) {
    return (uint32_t)(esp_timer_get_time() / 1000);
}

// -----------------------------------------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------------------------------------

/*
 * e22xxxtxx.h builds multi-part output lines (no trailing \n on some calls),
 * so we use printf rather than ESP_LOG which adds prefixes and newlines.
 */
static bool debug_e22 = false;
#define PRINTF_DEBUG(fmt, ...) \
    do { \
        if (debug_e22) \
            printf(fmt, ##__VA_ARGS__); \
    } while (0)
#define PRINTF_INFO  printf
#define PRINTF_ERROR printf

static bool serial_installed = false;
bool serial_connect(void) {
    const uart_config_t uart_config = {
        .baud_rate = 9600,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
        .source_clk = UART_SCLK_DEFAULT,
    };
    esp_err_t err;
    if ((err = uart_driver_install(E22_UART, E22_UART_BUF_SIZE, E22_UART_BUF_SIZE, 0, NULL, 0)) != ESP_OK) {
        ESP_LOGE(TAG, "uart_driver_install: %s", esp_err_to_name(err));
        return false;
    }
    serial_installed = true;
    if ((err = uart_param_config(E22_UART, &uart_config)) != ESP_OK) {
        ESP_LOGE(TAG, "uart_param_config: %s", esp_err_to_name(err));
        uart_driver_delete(E22_UART);
        return false;
    }
    if ((err = uart_set_pin(E22_UART, PIN_E22_RXD, PIN_E22_TXD, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE)) != ESP_OK) {
        ESP_LOGE(TAG, "uart_set_pin: %s", esp_err_to_name(err));
        uart_driver_delete(E22_UART);
        return false;
    }
    return true;
}
void serial_disconnect(void) {
    if (serial_installed) {
        uart_driver_delete(E22_UART);
        serial_installed = false;
    }
}
void serial_flush(void) {
    uart_flush(E22_UART);
}
int serial_write(const uint8_t *buffer, const int length) {
    vTaskDelay(pdMS_TO_TICKS(50));
    return uart_write_bytes(E22_UART, buffer, (size_t)length);
}
int serial_read(uint8_t *buffer, const int length, const uint32_t timeout_ms) {
    vTaskDelay(pdMS_TO_TICKS(50));
    return uart_read_bytes(E22_UART, buffer, (size_t)length, pdMS_TO_TICKS(timeout_ms));
}

// -----------------------------------------------------------------------------------------------------------------------------------------
// EBYTE E22-xxxTxx software interface (DIP variant)
// -----------------------------------------------------------------------------------------------------------------------------------------

#define E22900T22_SUPPORT_MODULE_DIP
#undef E22900T22_SUPPORT_MODULE_USB
#include "e22xxxtxx.h"
inline void __sleep_ms(const uint32_t ms) {
    vTaskDelay(pdMS_TO_TICKS(ms));
}

static void e22_gpio_init(void) {
    gpio_set_direction(PIN_E22_M0, GPIO_MODE_OUTPUT);
    gpio_set_level(PIN_E22_M0, 1);
    gpio_set_direction(PIN_E22_M1, GPIO_MODE_OUTPUT);
    gpio_set_level(PIN_E22_M1, 1);
    gpio_set_direction(PIN_E22_AUX, GPIO_MODE_INPUT);
    gpio_pullup_en(PIN_E22_AUX);
}
static void e22_set_pin_mx(const bool pin_m0, const bool pin_m1) {
    gpio_set_level(PIN_E22_M0, pin_m0 ? 1 : 0);
    gpio_set_level(PIN_E22_M1, pin_m1 ? 1 : 0);
}
static bool e22_get_pin_aux(void) {
    return gpio_get_level(PIN_E22_AUX) == 1;
}
static e22900t22_config_t e22_config = {
    .address = 0x0008,
    .network = 0x00,
    .channel = 0x17, /* 850.125 + 23 = 873.125 MHz */
    .packet_maxsize = E22900T22_CONFIG_PACKET_MAXSIZE_DEFAULT,
    .packet_maxrate = E22900T22_CONFIG_PACKET_MAXRATE_DEFAULT,
    .crypt = E22900T22_CONFIG_CRYPT_DEFAULT,
    .wor_enabled = E22900T22_CONFIG_WOR_ENABLED_DEFAULT,
    .wor_cycle = E22900T22_CONFIG_WOR_CYCLE_DEFAULT,
    .transmit_power = E22900T22_CONFIG_TRANSMIT_POWER_DEFAULT,
    .listen_before_transmit = true,
    .rssi_packet = true,
    .rssi_channel = true,
    .read_timeout_command = E22900T22_CONFIG_READ_TIMEOUT_COMMAND_DEFAULT,
    .read_timeout_packet = E22900T22_CONFIG_READ_TIMEOUT_PACKET_DEFAULT,
    .set_pin_mx = e22_set_pin_mx,
    .get_pin_aux = e22_get_pin_aux,
    .debug = false,
};

// -----------------------------------------------------------------------------------------------------------------------------------------
// iotdata — variant suite + simulator (unity build, encode-only)
// -----------------------------------------------------------------------------------------------------------------------------------------

/*
 * Strip everything except the encoder for minimal ESP32 build:
 *   - NO_DECODE:  no decoder (encoder-only)
 *   - NO_JSON:    no cJSON dependency
 *   - NO_DUMP:    no dump output
 *   - NO_PRINT:   no print output
 *   - NO_FLOATING: iotdata_float_t = int32_t (value * 100)
 *
 * The simulator's _to_temp/_to_speed/_to_dose helpers handle the
 * conversion from internal centi-units to iotdata_float_t correctly
 * under NO_FLOATING (they pass centi-values directly).
 */
#define IOTDATA_NO_DECODE
#define IOTDATA_NO_JSON
#define IOTDATA_NO_DUMP
#define IOTDATA_NO_PRINT
#define IOTDATA_NO_FLOATING
#include "iotdata_variant_simulator.h"
#include "iotdata_variant_simulator.c"
#include "iotdata.c"

// -----------------------------------------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------------------------------------

static uint32_t tx_count = 0, tx_errors = 0;

static void transmit_packet(const iotsim_packet_t *pkt) {

    printf("device: e22 tx #%06" PRIu32 ": stn=%-4" PRIu16 " %-18s seq=%06" PRIu16 " bytes=%-2" PRIu32 "  hex:", tx_count, pkt->station_id, iotdata_vsuite_name(pkt->variant), pkt->sequence, (uint32_t)pkt->len);
    for (size_t i = 0; i < pkt->len; i++)
        printf(" %02" PRIX8, pkt->buf[i]);
    printf("\n");

    if (device_packet_write((const unsigned char *)pkt->buf, (int)pkt->len))
        tx_count++;
    else {
        tx_errors++;
        ESP_LOGE(TAG, "device: e22 tx device_packet_write failed (errors=%" PRIu32 ")", tx_errors);
    }
}

// -----------------------------------------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------------------------------------

void app_halt(void) {
    ESP_LOGE(TAG, "halted");
    for (;;)
        vTaskDelay(pdMS_TO_TICKS(1000));
}

void app_main(void) {

    /* let UART0 (console) settle */
    setbuf(stdout, NULL);
    vTaskDelay(pdMS_TO_TICKS(STARTUP_DELAY_MS));
    ESP_LOGI(TAG, "iotdata multi-sensor simulator transmitter");

    e22_gpio_init();
    if (!serial_connect()) {
        ESP_LOGE(TAG, "serial_connect failed");
        app_halt();
    }
    if (!device_connect(E22900T22_MODULE_DIP, &e22_config)) {
        ESP_LOGE(TAG, "device_connect failed");
        app_halt();
    }
    ESP_LOGI(TAG, "device: e22 connected");

    if (!(device_mode_config() && device_info_read() && device_config_read_and_update() && device_mode_transfer())) {
        ESP_LOGE(TAG, "device: e22 mode/info/config failed");
        app_halt();
    }
    ESP_LOGI(TAG, "device: e22 configured, transfer mode active");

    /* --- Simulator init (hardware RNG seed for unique run each boot) --- */
    const uint32_t seed = esp_random();
    const uint32_t t0 = millis();

    static iotsim_t sim; // too large for stack
    iotsim_init(&sim, seed, t0);

    ESP_LOGI(TAG, "simulator: %d sensors, seed=0x%08" PRIX32, IOTSIM_NUM_SENSORS, seed);
    for (int i = 0; i < IOTSIM_NUM_SENSORS; i++) {
        const iotsim_sensor_t *s = iotsim_sensor(&sim, i);
        ESP_LOGI(TAG, "  [%2d] %-18s stn=%-4" PRIu16 " bat=%" PRIu8 "%%", i, iotdata_vsuite_name(s->variant), s->station_id, s->battery);
    }

    /* --- Main loop — poll simulator, transmit when ready --- */
    uint32_t rssi_last = 0;
    int rssi_channel_dbm = -100;
    uint32_t last_status_tx = 0;

    for (;;) {
        const uint32_t now = millis();

        if (now - rssi_last >= RSSI_INTERVAL_MS) {
            rssi_last = now;
            unsigned char rssi_raw;
            if (device_channel_rssi_read(&rssi_raw))
                rssi_channel_dbm = get_rssi_dbm(rssi_raw);
        }

        iotsim_packet_t pkt;
        while (iotsim_poll(&sim, now, &pkt))
            transmit_packet(&pkt);

        if (tx_count >= last_status_tx + STATUS_EVERY_N_TX) {
            last_status_tx = tx_count;
            ESP_LOGI(TAG, "status: tx=%" PRIu32 " errors=%" PRIu32 " rssi=%d dBm uptime=%" PRIu32 "s", tx_count, tx_errors, rssi_channel_dbm, (now - t0) / 1000);
        }

        vTaskDelay(pdMS_TO_TICKS(POLL_INTERVAL_MS));
    }
}

// -----------------------------------------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------------------------------------

// trap all floating point calls

void __addsf3(void) {
    __builtin_trap();
}
void __mulsf3(void) {
    __builtin_trap();
}
void __divsf3(void) {
    __builtin_trap();
}
void __fixsfsi(void) {
    __builtin_trap();
}
void __floatsisf(void) {
    __builtin_trap();
}
void __fixunssfsi(void) {
    __builtin_trap();
}
void __floatunsisf(void) {
    __builtin_trap();
}
void __adddf3(void) {
    __builtin_trap();
}
void __muldf3(void) {
    __builtin_trap();
}
void __divdf3(void) {
    __builtin_trap();
}

// -----------------------------------------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------------------------------------
