// -----------------------------------------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------------------------------------

/*
 * E22-900T22D multi-sensor simulator transmitter (ESP-IDF)
 *
 * Simulates 16 sensors across 9 variant types and transmits iotdata-encoded
 * packets via E22-900T22D LoRa radio module at randomised intervals (5-15s).
 *
 * No real sensors — all readings are generated by iotdata_variant_simulator.
 * The LoRa module handles duty cycling.
 */

// -----------------------------------------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------------------------------------

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
#pragma GCC diagnostic ignored "-Wnested-externs"
#pragma GCC diagnostic ignored "-Wredundant-decls"
#include "esp_log.h"
#include "esp_timer.h"
#include "esp_random.h"
#include "esp_rom_sys.h"
#include "driver/gpio.h"
#include "driver/uart.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#pragma GCC diagnostic pop

// -----------------------------------------------------------------------------------------------------------------------------------------
// Configuration
// -----------------------------------------------------------------------------------------------------------------------------------------

#define STARTUP_DELAY_MS  (3 * 1000)
#define RSSI_INTERVAL_MS  (5 * 1000)
#define POLL_INTERVAL_MS  100 /* simulator poll granularity */
#define STATUS_EVERY_N_TX 50  /* print status every N transmissions */

// -----------------------------------------------------------------------------------------------------------------------------------------
// Pin assignments (ESP32-C3)
// -----------------------------------------------------------------------------------------------------------------------------------------

#define PIN_E22_M0        GPIO_NUM_5
#define PIN_E22_M1        GPIO_NUM_6
#define PIN_E22_RXD       GPIO_NUM_7  /* ESP TX -> module RXD */
#define PIN_E22_TXD       GPIO_NUM_20 /* module TXD -> ESP RX */
#define PIN_E22_AUX       GPIO_NUM_21

#define E22_UART          UART_NUM_1
#define E22_UART_BUF_SIZE 512

// -----------------------------------------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------------------------------------

static const char *TAG = "app";

static inline uint32_t millis(void) {
    return (uint32_t)(esp_timer_get_time() / 1000);
}

// -----------------------------------------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------------------------------------

/*
 * e22xxxtxx.h builds multi-part output lines (no trailing \n on some calls),
 * so we use printf rather than ESP_LOG which adds prefixes and newlines.
 */
static bool debug_e22 = false;
#define PRINTF_DEBUG(fmt, ...) \
    do { \
        if (debug_e22) \
            printf(fmt, ##__VA_ARGS__); \
    } while (0)
#define PRINTF_INFO  printf
#define PRINTF_ERROR printf

inline void __sleep_ms(const unsigned long ms) {
    vTaskDelay(pdMS_TO_TICKS(ms));
}

static bool serial_uart_installed = false;

bool serial_connect(void) {
    const uart_config_t uart_config = {
        .baud_rate = 9600,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
        .source_clk = UART_SCLK_DEFAULT,
    };
    esp_err_t err;
    if ((err = uart_driver_install(E22_UART, E22_UART_BUF_SIZE, E22_UART_BUF_SIZE, 0, NULL, 0)) != ESP_OK) {
        ESP_LOGE(TAG, "uart_driver_install: %s", esp_err_to_name(err));
        return false;
    }
    serial_uart_installed = true;
    if ((err = uart_param_config(E22_UART, &uart_config)) != ESP_OK) {
        ESP_LOGE(TAG, "uart_param_config: %s", esp_err_to_name(err));
        return false;
    }
    if ((err = uart_set_pin(E22_UART, PIN_E22_RXD, PIN_E22_TXD, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE)) != ESP_OK) {
        ESP_LOGE(TAG, "uart_set_pin: %s", esp_err_to_name(err));
        return false;
    }
    return true;
}

void serial_disconnect(void) {
    if (serial_uart_installed) {
        uart_driver_delete(E22_UART);
        serial_uart_installed = false;
    }
}

void serial_flush(void) {
    uart_flush(E22_UART);
}

int serial_write(const unsigned char *buffer, const int length) {
    vTaskDelay(pdMS_TO_TICKS(50));
    return uart_write_bytes(E22_UART, buffer, (size_t)length);
}

int serial_read(unsigned char *buffer, const int length, const int timeout_ms) {
    vTaskDelay(pdMS_TO_TICKS(50));
    return uart_read_bytes(E22_UART, buffer, (size_t)length, pdMS_TO_TICKS(timeout_ms));
}

// -----------------------------------------------------------------------------------------------------------------------------------------
// E22-900T22D module (DIP variant, hardware mode switching via M0/M1/AUX)
// -----------------------------------------------------------------------------------------------------------------------------------------

#define E22900T22_SUPPORT_MODULE_DIP
#undef E22900T22_SUPPORT_MODULE_USB
#include "e22xxxtxx.h"

static void e22_gpio_init(void) {
    gpio_set_direction(PIN_E22_M0, GPIO_MODE_OUTPUT);
    gpio_set_level(PIN_E22_M0, 1);
    gpio_set_direction(PIN_E22_M1, GPIO_MODE_OUTPUT);
    gpio_set_level(PIN_E22_M1, 1);
    gpio_set_direction(PIN_E22_AUX, GPIO_MODE_INPUT);
    gpio_pullup_en(PIN_E22_AUX);
}

static void e22_set_pin_mx(const bool pin_m0, const bool pin_m1) {
    gpio_set_level(PIN_E22_M0, pin_m0 ? 1 : 0);
    gpio_set_level(PIN_E22_M1, pin_m1 ? 1 : 0);
}

static bool e22_get_pin_aux(void) {
    return gpio_get_level(PIN_E22_AUX) == 1;
}

static e22900t22_config_t e22_config = {
    .address = 0x0008,
    .network = 0x00,
    .channel = 0x17, /* 850.125 + 23 = 873.125 MHz */
    .packet_maxsize = CONFIG_PACKET_MAXSIZE_DEFAULT,
    .listen_before_transmit = true,
    .rssi_packet = true,
    .rssi_channel = true,
    .read_timeout_command = CONFIG_READ_TIMEOUT_COMMAND_DEFAULT,
    .read_timeout_packet = CONFIG_READ_TIMEOUT_PACKET_DEFAULT,
    .set_pin_mx = e22_set_pin_mx,
    .get_pin_aux = e22_get_pin_aux,
    .debug = false,
};

// -----------------------------------------------------------------------------------------------------------------------------------------
// iotdata — variant suite + simulator (unity build, encode-only)
// -----------------------------------------------------------------------------------------------------------------------------------------

/*
 * Strip everything except the encoder for minimal ESP32 build:
 *   - NO_DECODE:  no decoder (encoder-only)
 *   - NO_JSON:    no cJSON dependency
 *   - NO_DUMP:    no dump output
 *   - NO_PRINT:   no print output
 *   - NO_FLOATING: iotdata_float_t = int32_t (value * 100)
 *
 * The simulator's _to_temp/_to_speed/_to_dose helpers handle the
 * conversion from internal centi-units to iotdata_float_t correctly
 * under NO_FLOATING (they pass centi-values directly).
 */
#define IOTDATA_NO_DECODE
#define IOTDATA_NO_JSON
#define IOTDATA_NO_DUMP
#define IOTDATA_NO_PRINT
#define IOTDATA_NO_FLOATING
#include "iotdata_variant_simulator.h"
#include "iotdata_variant_simulator.c"
#include "iotdata.c"

// -----------------------------------------------------------------------------------------------------------------------------------------
// Packet transmission
// -----------------------------------------------------------------------------------------------------------------------------------------

static uint32_t tx_count = 0;
static uint32_t tx_errors = 0;

static void transmit_packet(const iotsim_packet_t *pkt) {

    printf("tx #%u: stn=%u %-18s seq=%u %zu B  hex:", (unsigned)tx_count, pkt->station_id, iotdata_vsuite_name(pkt->variant), pkt->sequence, pkt->len);
    for (size_t i = 0; i < pkt->len; i++)
        printf(" %02X", pkt->buf[i]);
    printf("\n");

    if (device_packet_write((const unsigned char *)pkt->buf, (int)pkt->len))
        tx_count++;
    else {
        tx_errors++;
        ESP_LOGE(TAG, "tx: device_packet_write failed (errors=%u)", (unsigned)tx_errors);
    }
}

// -----------------------------------------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------------------------------------

void app_halt(void) {
    ESP_LOGE(TAG, "halted");
    for (;;)
        vTaskDelay(pdMS_TO_TICKS(1000));
}

void app_main(void) {

    /* let UART0 (console) settle */
    setbuf(stdout, NULL);
    vTaskDelay(pdMS_TO_TICKS(STARTUP_DELAY_MS));
    ESP_LOGI(TAG, "iotdata multi-sensor simulator transmitter");

    e22_gpio_init();
    if (!serial_connect()) {
        ESP_LOGE(TAG, "serial_connect failed");
        app_halt();
    }
    if (!device_connect(E22900T22_MODULE_DIP, &e22_config)) {
        ESP_LOGE(TAG, "device_connect failed");
        app_halt();
    }
    ESP_LOGI(TAG, "e22: connected");

    if (!(device_mode_config() && device_info_read() && device_config_read_and_update() && device_mode_transfer())) {
        ESP_LOGE(TAG, "e22: mode/info/config failed");
        app_halt();
    }
    ESP_LOGI(TAG, "e22: configured, transfer mode active");

    /* --- Simulator init (hardware RNG seed for unique run each boot) --- */
    const uint32_t seed = esp_random();
    const uint32_t t0 = millis();

    iotsim_t sim;
    iotsim_init(&sim, seed, t0);

    ESP_LOGI(TAG, "simulator: %d sensors, seed=0x%08X", IOTSIM_NUM_SENSORS, (unsigned)seed);
    for (int i = 0; i < IOTSIM_NUM_SENSORS; i++) {
        const iotsim_sensor_t *s = iotsim_sensor(&sim, i);
        ESP_LOGI(TAG, "  [%2d] %-18s stn=%u bat=%u%%", i, iotdata_vsuite_name(s->variant), s->station_id, s->battery);
    }

    /* --- Main loop — poll simulator, transmit when ready --- */
    uint32_t last_rssi = 0;
    int channel_rssi_dbm = -100;
    uint32_t last_status_tx = 0;

    ESP_LOGI(TAG, "looping");

    for (;;) {
        const uint32_t now = millis();

        if (now - last_rssi >= RSSI_INTERVAL_MS) {
            last_rssi = now;
            unsigned char rssi_raw;
            if (device_channel_rssi_read(&rssi_raw))
                channel_rssi_dbm = get_rssi_dbm(rssi_raw);
        }

        iotsim_packet_t pkt;
        while (iotsim_poll(&sim, now, &pkt))
            transmit_packet(&pkt);

        if (tx_count >= last_status_tx + STATUS_EVERY_N_TX) {
            last_status_tx = tx_count;
            ESP_LOGI(TAG, "status: tx=%u errors=%u rssi=%d dBm uptime=%us", (unsigned)tx_count, (unsigned)tx_errors, channel_rssi_dbm, (unsigned)((now - t0) / 1000));
        }

        vTaskDelay(pdMS_TO_TICKS(POLL_INTERVAL_MS));
    }
}

// -----------------------------------------------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------------------------------------
